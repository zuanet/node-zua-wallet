"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chunks = exports.throttle = exports.createHash = exports.Deferred = exports.dpc = exports.UID = exports.now = exports.ZUA = exports.sha256 = exports.Decimal = void 0;
const crypto_js_1 = __importDefault(require("crypto-js"));
const decimal_js_1 = require("decimal.js");
Object.defineProperty(exports, "Decimal", { enumerable: true, get: function () { return decimal_js_1.Decimal; } });
const sha256 = (str) => {
    return crypto_js_1.default.SHA256(str).toString(crypto_js_1.default.enc.Hex);
};
exports.sha256 = sha256;
const ZUA = (v) => {
    var [int, frac] = (new decimal_js_1.Decimal(v)).mul(1e-8).toFixed(8).split('.');
    int = int.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    frac = frac === null || frac === void 0 ? void 0 : frac.replace(/0+$/, '');
    return frac ? `${int}.${frac}` : int;
};
exports.ZUA = ZUA;
exports.now = Date.now || function () {
    return new Date().getTime();
};
const UID = (join = '') => exports.now() + join + (Math.random() * 100000).toFixed(0);
exports.UID = UID;
const dpc = (delay, fn) => {
    if (typeof delay == 'function') {
        let temp = fn;
        fn = delay;
        delay = temp;
    }
    return setTimeout(fn, delay || 0);
};
exports.dpc = dpc;
const Deferred = () => {
    let methods = {};
    let promise = new Promise((resolve, reject) => {
        methods = { resolve, reject };
    });
    Object.assign(promise, methods);
    return promise;
};
exports.Deferred = Deferred;
const createHash = (str) => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash &= hash; // Convert to 32bit integer
    }
    //console.log("hash", str, hash)
    return new Uint32Array([hash])[0].toString(36);
};
exports.createHash = createHash;
// Returns a function, that, when invoked, will only be triggered at most once
// during a given window of time. Normally, the throttled function will run
// as much as it can, without ever going more than once per `wait` duration;
// but if you'd like to disable the execution on the leading edge, pass
// `{leading: false}`. To disable execution on the trailing edge, ditto.
const throttle = (func, wait, options = {}) => {
    let timeout, context, args, result;
    let previous = 0;
    let later = function () {
        previous = options.leading === false ? 0 : exports.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout)
            context = args = null;
    };
    let throttled = function () {
        let _now = exports.now();
        if (!previous && options.leading === false)
            previous = _now;
        let remaining = wait - (_now - previous);
        //@ts-ignore
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = _now;
            result = func.apply(context, args);
            if (!timeout)
                context = args = null;
        }
        else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };
    //@ts-ignore
    throttled.cancel = function () {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
    };
    return throttled;
};
exports.throttle = throttle;
const chunks = (list, size) => {
    return list.length ? [list.slice(0, size), ...exports.chunks(list.slice(size), size)] : [];
};
exports.chunks = chunks;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vdXRpbHMvaGVscGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDBEQUFpQztBQUNqQywyQ0FBcUM7QUFDN0Isd0ZBREMsb0JBQU8sT0FDRDtBQUVSLE1BQU0sTUFBTSxHQUFHLENBQUMsR0FBVSxFQUFDLEVBQUU7SUFDaEMsT0FBTyxtQkFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsbUJBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUE7QUFDMUQsQ0FBQyxDQUFBO0FBRlksUUFBQSxNQUFNLFVBRWxCO0FBRU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFRLEVBQVUsRUFBRTtJQUNwQyxJQUFJLENBQUMsR0FBRyxFQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxvQkFBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbEUsR0FBRyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDaEQsSUFBSSxHQUFHLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxPQUFPLENBQUMsS0FBSyxFQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQy9CLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQ3pDLENBQUMsQ0FBQTtBQUxZLFFBQUEsR0FBRyxPQUtmO0FBRVksUUFBQSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsSUFBSTtJQUMzQixPQUFPLElBQUksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDaEMsQ0FBQyxDQUFBO0FBRU0sTUFB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QUFJLENBQUMsRUFBRSxHQUFHLGNBQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtBQUN0RixDQUFDLENBQUE7QUFGWSxRQUFBLE1BQU0sVUFFbEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ3J5cHRvSlMgZnJvbSAnY3J5cHRvLWpzJztcbmltcG9ydCB7IERlY2ltYWwgfSBmcm9tICdkZWNpbWFsLmpzJztcbmV4cG9ydCB7RGVjaW1hbH07XG5cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAoc3RyOnN0cmluZyk9PntcbiAgICByZXR1cm4gQ3J5cHRvSlMuU0hBMjU2KHN0cikudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLkhleClcbn1cblxuZXhwb3J0IGNvbnN0IEtBUyA9ICh2Om51bWJlcik6IHN0cmluZyA9PntcbiAgICB2YXIgW2ludCxmcmFjXSA9IChuZXcgRGVjaW1hbCh2KSkubXVsKDFlLTgpLnRvRml4ZWQoOCkuc3BsaXQoJy4nKTtcbiAgICBpbnQgPSBpbnQucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgXCIsXCIpO1xuICAgIGZyYWMgPSBmcmFjPy5yZXBsYWNlKC8wKyQvLCcnKTtcbiAgICByZXR1cm4gZnJhYyA/IGAke2ludH0uJHtmcmFjfWAgOiBpbnQ7XG59XG5cbmV4cG9ydCBjb25zdCBub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59XG5cbmV4cG9ydCBjb25zdCBVSUQgPSAoam9pbj0nJyk9Pm5vdygpK2pvaW4rKE1hdGgucmFuZG9tKCkqMTAwMDAwKS50b0ZpeGVkKDApO1xuXG5leHBvcnQgY29uc3QgZHBjID0gKGRlbGF5OiBudW1iZXIgfCBGdW5jdGlvbiwgZm4gPyA6IEZ1bmN0aW9uIHwgbnVtYmVyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkZWxheSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxldCB0ZW1wID0gZm4gYXMgbnVtYmVyO1xuICAgICAgICBmbiA9IGRlbGF5O1xuICAgICAgICBkZWxheSA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiBzZXRUaW1lb3V0KGZuIGFzIEZ1bmN0aW9uLCBkZWxheSB8fCAwKTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRGVmZXJyZWRQcm9taXNlIGV4dGVuZHMgUHJvbWlzZTxhbnk+IHtcbiAgICByZXNvbHZlKGRhdGE/OmFueSk6dm9pZDtcbiAgICByZWplY3QoZXJyb3I/OmFueSk6dm9pZDtcbn1cbmV4cG9ydCBjb25zdCBEZWZlcnJlZCA9ICgpOiBEZWZlcnJlZFByb21pc2U9PntcbiAgICBsZXQgbWV0aG9kcyA9IHt9O1xuICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgbWV0aG9kcyA9IHtyZXNvbHZlLCByZWplY3R9O1xuICAgIH0pXG4gICAgT2JqZWN0LmFzc2lnbihwcm9taXNlLCBtZXRob2RzKTtcbiAgICByZXR1cm4gcHJvbWlzZSBhcyBEZWZlcnJlZFByb21pc2U7XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVIYXNoID0gKHN0cjpzdHJpbmcpID0+IHtcbiAgICBsZXQgaGFzaCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hhcjtcbiAgICAgICAgaGFzaCAmPSBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZyhcImhhc2hcIiwgc3RyLCBoYXNoKVxuICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoW2hhc2hdKVswXS50b1N0cmluZygzNik7XG59O1xuXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2Vcbi8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3Ncbi8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuZXhwb3J0IGNvbnN0IHRocm90dGxlID0gKFxuICAgIGZ1bmM6IEZ1bmN0aW9uLCB3YWl0OiBudW1iZXIsIG9wdGlvbnM6IFxuICAgIHtsZWFkaW5nPzpib29sZWFuLCB0cmFpbGluZz86Ym9vbGVhbn0gPSB7fVxuKSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ6IGFueSwgY29udGV4dDogYW55LCBhcmdzOiBhbnksIHJlc3VsdDogYW55O1xuICAgIGxldCBwcmV2aW91cyA9IDA7XG5cbiAgICBsZXQgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IG5vdygpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KVxuICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICBsZXQgdGhyb3R0bGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxldCBfbm93ID0gbm93KCk7XG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgIHByZXZpb3VzID0gX25vdztcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IHdhaXQgLSAoX25vdyAtIHByZXZpb3VzKTtcbiAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91cyA9IF9ub3c7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0KVxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy9AdHMtaWdub3JlXG4gICAgdGhyb3R0bGVkLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHByZXZpb3VzID0gMDtcbiAgICAgICAgdGltZW91dCA9IGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRocm90dGxlZDtcbn1cblxuZXhwb3J0IGNvbnN0IGNodW5rcyA9IChsaXN0OmFueVtdLCBzaXplOm51bWJlcik6IChhbnlbXSlbXT0+e1xuICAgIHJldHVybiBsaXN0Lmxlbmd0aCA/IFtsaXN0LnNsaWNlKDAsIHNpemUpLCAuLi5jaHVua3MobGlzdC5zbGljZShzaXplKSwgc2l6ZSldIDogW11cbn0iXX0=